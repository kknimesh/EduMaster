name: Final Fix - No Logging Issues

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1

jobs:
  final-fix:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Account ID
        id: account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Fix ECS Task Execution Role Permissions
        run: |
          echo "🔧 Adding CloudWatch permissions to ECS Task Execution Role..."
          
          # Create policy document for CloudWatch logs
          cat > logs-policy.json << 'EOF'
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "logs:CreateLogGroup",
                  "logs:CreateLogStream",
                  "logs:PutLogEvents",
                  "logs:DescribeLogGroups",
                  "logs:DescribeLogStreams"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          # Create and attach the policy
          aws iam create-policy \
            --policy-name ECSTaskExecutionLogsPolicy \
            --policy-document file://logs-policy.json \
            --description "Allow ECS tasks to create CloudWatch logs" 2>/dev/null || echo "Policy already exists"
          
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole \
            --policy-arn "arn:aws:iam::${{ steps.account.outputs.account_id }}:policy/ECSTaskExecutionLogsPolicy" || echo "Policy already attached"
          
          echo "✅ Permissions updated"

      - name: Create Pre-existing Log Group
        run: |
          # Create log group manually to avoid permission issues
          aws logs create-log-group --log-group-name "/ecs/edumaster-working" || echo "Log group already exists"
          echo "✅ Log group ready"

      - name: Clean Up Old Tasks
        run: |
          echo "🧹 Cleaning up failed tasks..."
          CLUSTER_NAME=$(aws ecs list-clusters --query 'clusterArns[0]' --output text | xargs basename)
          
          # Stop any running tasks
          for TASK_ARN in $(aws ecs list-tasks --cluster $CLUSTER_NAME --query 'taskArns' --output text); do
            if [ -n "$TASK_ARN" ]; then
              echo "Stopping task: $TASK_ARN"
              aws ecs stop-task --cluster $CLUSTER_NAME --task $TASK_ARN 2>/dev/null || echo "Failed to stop task"
            fi
          done
          
          # Wait for cleanup
          sleep 30

      - name: Create Working Task Definition
        run: |
          echo "📝 Creating simple working task definition..."
          
          aws ecs register-task-definition \
            --family edumaster-working \
            --network-mode awsvpc \
            --requires-compatibilities FARGATE \
            --cpu 256 \
            --memory 512 \
            --execution-role-arn "arn:aws:iam::${{ steps.account.outputs.account_id }}:role/ecsTaskExecutionRole" \
            --container-definitions '[{
              "name": "nginx-web",
              "image": "nginx:alpine",
              "portMappings": [{"containerPort": 80, "protocol": "tcp"}],
              "essential": true,
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/edumaster-working",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }]'
          
          echo "✅ Task definition created successfully"

      - name: Set Up Network Infrastructure
        id: network
        run: |
          echo "🌐 Setting up network infrastructure..."
          
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
          
          # Get public subnet
          SUBNET_ID=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=map-public-ip-on-launch,Values=true" \
            --query 'Subnets[0].SubnetId' \
            --output text)
          
          # Create security group
          SG_ID=$(aws ec2 create-security-group \
            --group-name "edumaster-working-$(date +%s)" \
            --description "Allow HTTP for EduMaster" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          
          # Allow HTTP
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0
          
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "security_group_id=$SG_ID" >> $GITHUB_OUTPUT
          
          echo "Network setup complete:"
          echo "VPC: $VPC_ID"
          echo "Subnet: $SUBNET_ID"
          echo "Security Group: $SG_ID"

      - name: Run Working Container
        id: run-container
        run: |
          echo "🚀 Starting container..."
          
          CLUSTER_NAME=$(aws ecs list-clusters --query 'clusterArns[0]' --output text | xargs basename)
          
          # Run the task
          TASK_ARN=$(aws ecs run-task \
            --cluster $CLUSTER_NAME \
            --task-definition edumaster-working:1 \
            --launch-type FARGATE \
            --platform-version LATEST \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.network.outputs.subnet_id }}],securityGroups=[${{ steps.network.outputs.security_group_id }}],assignPublicIp=ENABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "Container started: $TASK_ARN"
          
          # Wait for container to be running
          echo "⏳ Waiting for container to start (60 seconds)..."
          sleep 60

      - name: Get Container Details and Create Load Balancer Connection
        run: |
          CLUSTER_NAME=$(aws ecs list-clusters --query 'clusterArns[0]' --output text | xargs basename)
          TASK_ARN="${{ steps.run-container.outputs.task_arn }}"
          
          # Check task status
          echo "📊 Checking task status..."
          TASK_STATUS=$(aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN --query 'tasks[0].lastStatus' --output text)
          
          echo "Task Status: $TASK_STATUS"
          
          if [ "$TASK_STATUS" = "RUNNING" ]; then
            echo "✅ Container is RUNNING!"
            
            # Get private IP
            PRIVATE_IP=$(aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN --query 'tasks[0].attachments[0].details[?name==`privateIPv4Address`].value' --output text)
            
            # Get ENI ID
            ENI_ID=$(aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
            
            # Get public IP
            PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text 2>/dev/null || echo "None")
            
            echo "Private IP: $PRIVATE_IP"
            echo "Public IP: $PUBLIC_IP"
            echo "ENI ID: $ENI_ID"
            
            # Test direct access
            if [ "$PUBLIC_IP" != "None" ] && [ -n "$PUBLIC_IP" ]; then
              echo ""
              echo "🌐 Direct container access: http://$PUBLIC_IP"
              echo "Testing direct access..."
              curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" "http://$PUBLIC_IP" || echo "Direct access test failed"
            fi
            
            # Set up Load Balancer
            echo ""
            echo "🔗 Connecting to Load Balancer..."
            
            # Create target group
            TG_ARN=$(aws elbv2 create-target-group \
              --name "edumaster-final-$(date +%s | tail -c 5)" \
              --protocol HTTP \
              --port 80 \
              --vpc-id ${{ steps.network.outputs.vpc_id }} \
              --target-type ip \
              --health-check-enabled \
              --health-check-path "/" \
              --health-check-interval-seconds 30 \
              --health-check-timeout-seconds 5 \
              --healthy-threshold-count 2 \
              --unhealthy-threshold-count 3 \
              --query 'TargetGroups[0].TargetGroupArn' \
              --output text)
            
            echo "Target Group: $TG_ARN"
            
            # Register target
            aws elbv2 register-targets \
              --target-group-arn $TG_ARN \
              --targets Id=$PRIVATE_IP,Port=80
            
            # Update load balancer
            LB_ARN=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?starts_with(LoadBalancerName, `edumaster-alb`)].LoadBalancerArn' --output text)
            
            # Delete old listeners
            for LISTENER_ARN in $(aws elbv2 describe-listeners --load-balancer-arn $LB_ARN --query 'Listeners[*].ListenerArn' --output text 2>/dev/null); do
              aws elbv2 delete-listener --listener-arn $LISTENER_ARN 2>/dev/null || echo "Failed to delete listener"
            done
            
            # Create new listener
            aws elbv2 create-listener \
              --load-balancer-arn $LB_ARN \
              --protocol HTTP \
              --port 80 \
              --default-actions Type=forward,TargetGroupArn=$TG_ARN
            
            echo "✅ Load Balancer updated"
            
            # Wait for health checks
            echo ""
            echo "⏳ Waiting for health checks (90 seconds)..."
            sleep 90
            
            # Show final status
            echo ""
            echo "📊 Final Target Health:"
            aws elbv2 describe-target-health --target-group-arn $TG_ARN --output table
            
            echo ""
            echo "🎉 DEPLOYMENT COMPLETE!"
            echo ""
            echo "🌐 Load Balancer URL: http://edumaster-alb-a94208ec-635552552.us-east-1.elb.amazonaws.com"
            if [ "$PUBLIC_IP" != "None" ]; then
              echo "🌐 Direct Container URL: http://$PUBLIC_IP"
            fi
            echo ""
            echo "✅ Your application should now be accessible!"
            
          else
            echo "❌ Container failed to start. Status: $TASK_STATUS"
            echo "Checking task details for errors..."
            aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN --query 'tasks[0]' --output json
          fi